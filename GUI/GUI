#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys, os, json, base64, traceback
import cv2
import numpy as np
import face_recognition

FACE_SCALE_DEFAULT = 0.5
FACE_TOL_DEFAULT = 0.5

known_face_encodings = []
known_face_names = []
known_dir = None

def log_json(obj):
    sys.stdout.write(json.dumps(obj, ensure_ascii=False) + "\n")
    sys.stdout.flush()

def load_db(folder_path: str, scale: float = FACE_SCALE_DEFAULT):
    global known_face_encodings, known_face_names, known_dir
    known_face_encodings = []
    known_face_names = []
    known_dir = folder_path

    if not os.path.isdir(folder_path):
        log_json({"type":"error", "msg": f"not a directory: {folder_path}"})
        return 0

    loaded = 0
    for person_name in os.listdir(folder_path):
        person_path = os.path.join(folder_path, person_name)
        if not os.path.isdir(person_path):
            continue
        for filename in os.listdir(person_path):
            if not filename.lower().endswith(('.png', '.jpg', '.jpeg')):
                continue
            try:
                image_path = os.path.join(person_path, filename)
                image = face_recognition.load_image_file(image_path)
                if scale != 1.0:
                    image = cv2.resize(image, (0, 0), fx=scale, fy=scale)
                encs = face_recognition.face_encodings(image, model='large')
                for enc in encs:
                    known_face_encodings.append(enc)
                    known_face_names.append(person_name)
                    loaded += 1
            except Exception as e:
                log_json({"type":"warn", "msg": f"failed {filename}: {e}"})
    return loaded

def infer_one(jpg_bytes: bytes, scale: float, tol: float):
    # JPG -> BGR
    npbuf = np.frombuffer(jpg_bytes, dtype=np.uint8)
    bgr = cv2.imdecode(npbuf, cv2.IMREAD_COLOR)
    if bgr is None:
        return {"ok": False, "msg": "cv2.imdecode failed"}

    small_bgr = cv2.resize(bgr, (0, 0), fx=scale, fy=scale)
    rgb = cv2.cvtColor(small_bgr, cv2.COLOR_BGR2RGB)

    locs = face_recognition.face_locations(rgb, model='hog')
    if not locs:
        return {"ok": True, "names": [], "locs": []}

    encs = face_recognition.face_encodings(rgb, locs, model='small')

    names = []
    for enc in encs:
        name = "Unknown"
        if known_face_encodings:
            matches = face_recognition.compare_faces(known_face_encodings, enc, tolerance=tol)
            dists = face_recognition.face_distance(known_face_encodings, enc)
            if len(dists) > 0:
                best = int(np.argmin(dists))
                if matches[best]:
                    name = known_face_names[best]
        names.append(name)

    # 원 해상도 좌표로 환산
    out_locs = []
    for (top, right, bottom, left) in locs:
        out_locs.append([
            int(top    / scale),
            int(right  / scale),
            int(bottom / scale),
            int(left   / scale),
        ])

    return {"ok": True, "names": names, "locs": out_locs}

def main():
    scale = FACE_SCALE_DEFAULT
    tol = FACE_TOL_DEFAULT
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        try:
            msg = json.loads(line)
            cmd = msg.get("cmd")
            if cmd == "init":
                scale = float(msg.get("scale", FACE_SCALE_DEFAULT))
                tol = float(msg.get("tolerance", FACE_TOL_DEFAULT))
                folder = msg.get("known_dir") or os.path.expanduser("~/known_faces")
                loaded = load_db(folder, scale=scale)
                log_json({"type":"init_ok", "loaded": loaded, "scale": scale, "tolerance": tol})
            elif cmd == "infer":
                jpg_b64 = msg.get("jpg_b64", "")
                jpg_bytes = base64.b64decode(jpg_b64)
                res = infer_one(jpg_bytes, scale=scale, tol=tol)
                if res.get("ok"):
                    log_json({"type":"infer_ok", "names": res["names"], "locs": res["locs"]})
                else:
                    log_json({"type":"error", "msg": res.get("msg", "infer failed")})
            elif cmd == "quit":
                log_json({"type":"bye"})
                break
        except Exception as e:
            log_json({"type":"error", "msg": f"{e}", "trace": traceback.format_exc()})

if __name__ == "__main__":
    main()
