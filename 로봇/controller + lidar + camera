#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import time
import math
import threading
import signal

import cv2
from flask import Flask, Response

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, Point, Twist
from std_msgs.msg import Bool
from collections import deque
from sensor_msgs.msg import LaserScan

# ===== 외부 모듈 =====
# pinkylib.Camera 는 Picamera2 기반 래퍼라고 가정
from pinkylib import Camera

# ===== Flask 설정 =====
PORT = int(os.getenv("PORT", "9819"))
WIDTH = int(os.getenv("WIDTH", "320"))
HEIGHT = int(os.getenv("HEIGHT", "240"))
JPEG_QUALITY = int(os.getenv("JPEG_QUALITY", "80"))

app = Flask(__name__)
_cam = None
_latest = None
_lock = threading.Lock()
_running = True

def camera_loop():
    """카메라 프레임을 지속 수집하여 최신 프레임만 보관"""
    global _cam, _latest, _running
    try:
        _cam = Camera()
        _cam.start(width=WIDTH, height=HEIGHT)
    except Exception as e:
        print(f"[CAM] 초기화 실패: {e}")
        return
    print("[CAM] 시작됨")
    while _running:
        try:
            frame = _cam.get_frame()
        except Exception:
            frame = None
        if frame is not None:
            with _lock:
                _latest = frame
        else:
            time.sleep(0.01)
    print("[CAM] 종료 루프 진입")
    try:
        _cam.close()
    except Exception:
        pass
    print("[CAM] 종료됨")

@app.route("/")
def index():
    # 간단 미리보기 페이지 (경로 수정: /video_feed)
    return "<h2>Robot Camera</h2><img src='/video_feed'/>"

@app.route("/video")  # 호환용 별칭
@app.route("/video_feed")
def video_feed():
    def gen():
        while True:
            with _lock:
                frame = None if _latest is None else _latest.copy()
            if frame is None:
                time.sleep(0.01)
                continue
            ok, buf = cv2.imencode(".jpg", frame, [cv2.IMWRITE_JPEG_QUALITY, JPEG_QUALITY])
            if not ok:
                continue
            yield (b"--frame\r\nContent-Type: image/jpeg\r\n\r\n" + buf.tobytes() + b"\r\n")
            time.sleep(0.01)
    return Response(gen(), mimetype="multipart/x-mixed-replace; boundary=frame")

def run_flask():
    # reloader 비활성화(스레드 2중 실행 방지)
    app.run(host="0.0.0.0", port=PORT, threaded=True, debug=False, use_reloader=False)

# ===== ROS2 ControllerNode =====

from pinky_controller.goal_points import GOAL_PATHS, FINAL_YAWS_DEG

# ===== 사용자 설정값 =====
YAW_THRESHOLD_DEG    = 7.0
ROTATE_SPEED_DEG     = 0.5
LINEAR_SPEED         = 0.5
GOAL_TOLERANCE       = 0.1

# ---- 라이다 관련 (필수 조정 포인트) ----
FRONT_FOV_DEG        = 60.0     # 원하는 스캔 폭(총각). 예: 30이면 앞 기준 ±15°
LIDAR_YAW_OFFSET_DEG = 180.0    # ★ 기준 시점(아래 FRONT_FOV_BASE_DEG에서) 맞춰둔 '앞' 중심각
FRONT_FOV_BASE_DEG   = 10.0     # ★ 과거에 앞방향이 "정확히" 맞았던 기준 폭(=10°에서 180°가 앞을 가리킴)
MIN_OBS_DIST_ON      = 0.25     # 장애물 감지(ON) 임계거리
MIN_OBS_DIST_OFF     = 0.75     # 장애물 해제(OFF) 임계거리(ON보다 크게)
USE_PCTL             = True     # 최솟값 대신 하위 백분위수 사용
PCTL                 = 20       # 하위 20% 지점

# ---- 회피 파라미터 ----
AVOID_FORWARD_DIST_1 = 0.10     # R45 후 1차 전진
AVOID_FORWARD_DIST_2 = 0.10     # L45 후 2차 전진
AVOID_FORWARD_DIST_3 = 0.10     # (현재 플로우에선 사용 X, 향후 확장용)
PULSE_ON_SEC         = 0.15     # 펄스 회전 on 시간
PULSE_RESET_SEC      = 0.20     # 펄스 타이머 리셋 간격

# ===== 좌표 기반 ON/OFF 트리거(원형 x,y,r) =====
ENABLE_POINTS  = [
    (1.37, 0.07, 0.15),   # ← 여기를 지나가면 ‘계속 ON’
]
DISABLE_POINTS = [
    (0.73, 0.10, 0.2),    # ← 여기를 지나가면 ‘계속 OFF’
]

OBSTACLE_INITIAL = False  # ★ 시작 기본값: True=처음부터 ON, False=처음부터 OFF

# 라디안 변환
YAW_THRESHOLD = math.radians(YAW_THRESHOLD_DEG)
ROTATE_SPEED  = math.radians(ROTATE_SPEED_DEG)

def normalize_angle(angle):
    while angle > math.pi:
        angle -= 2.0 * math.pi
    while angle < -math.pi:
        angle += 2.0 * math.pi
    return angle

class _CircleGate:
    """원 경계 바깥→안쪽으로 진입할 때 한 번만 True를 반환(래치 트리거)"""
    def __init__(self, x, y, r):
        self.x = float(x); self.y = float(y); self.r = float(r)
        self.prev_outside = True
    def update_and_fired(self, px, py):
        dx = px - self.x; dy = py - self.y
        inside = (dx*dx + dy*dy) <= (self.r * self.r)
        fired = (self.prev_outside and inside)
        self.prev_outside = (not inside)
        return fired
    def inside_now(self, px, py):
        dx = px - self.x; dy = py - self.y
        return (dx*dx + dy*dy) <= (self.r * self.r)

class ControllerNode(Node):
    def __init__(self):
        super().__init__('controller_node')

        # 로봇 상태
        self.robot_pose = None
        self.robot_yaw = None
        self.raw_yaw = None
        self.goal_pose = None
        self.state = 'IDLE'
        self.auto_start = False
        self.last_pulse_time = self.get_clock().now()

        # 목표 큐
        self.goal_queue = deque()
        self.final_target_yaw = -0.5 * math.pi  # 기본 -90도

        # 파라미터
        marker_id = self.declare_parameter('marker_id', 27).get_parameter_value().integer_value
        topic_name = f"marker_map/ID{marker_id}"

        # 구독/퍼블리셔
        self.create_subscription(PoseStamped, topic_name, self.robot_callback, 10)
        self.cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        self.timer = self.create_timer(0.15, self.control_loop)

        self.create_subscription(Bool, 'go_to_kitchen', lambda msg: self.load_path('kitchen', msg), 10)
        self.create_subscription(Bool, 'go_to_serving', lambda msg: self.load_path('serving', msg), 10)
        self.create_subscription(Bool, 'go_to_charge',  lambda msg: self.load_path('charge', msg), 10)
        self.create_subscription(Bool, 'go_to_room',    lambda msg: self.load_path('room', msg), 10)
        self.create_subscription(Bool, 'go_to_recall',  lambda msg: self.load_path('recall', msg), 10)
        self.create_subscription(Bool, 'go_to_return',  lambda msg: self.load_path('return', msg), 10)
        self.create_subscription(Bool, 'stop', self.cb_stop, 10)

        # 라이다
        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
        self.front_blocked = False

        # 래치형 ON/OFF 게이트
        self.enable_gates  = [_CircleGate(*p) for p in ENABLE_POINTS]
        self.disable_gates = [_CircleGate(*p) for p in DISABLE_POINTS]

        # ★ 초기 장애물 인식 상태
        self.obstacle_enabled = bool(OBSTACLE_INITIAL)
        self._first_pose_handled = False  # ★ 시작 시점 보정용

        self.get_logger().info(f"[INIT] controller_node 초기화 완료. 장애물 초기상태={self.obstacle_enabled}, 명령 토픽 대기 중.")

    # ---------- 경로 로드/전환 ----------
    def load_path(self, path_name, msg):
        if msg.data:
            if path_name in GOAL_PATHS:
                self.goal_queue.clear()
                for x, y in GOAL_PATHS[path_name]:
                    pt = Point(); pt.x, pt.y, pt.z = x, y, 0.0
                    self.goal_queue.append(pt)
                final_deg = FINAL_YAWS_DEG.get(path_name, -90.0)
                self.final_target_yaw = math.radians(final_deg)
                self.auto_start = True
                self.set_next_goal()
                self.get_logger().info(
                    f"[ROUTE] '{path_name}' 시작 "
                    f"(총 {len(self.goal_queue)+1 if self.goal_pose else len(self.goal_queue)}개 좌표, 최종각 {final_deg:.1f}°)"
                )
            else:
                self.get_logger().warn(f"[ERROR] '{path_name}' 경로가 존재하지 않음")

    def set_next_goal(self):
        if self.goal_queue:
            self.goal_pose = self.goal_queue.popleft()
            self.state = 'ROTATE'
            self.last_pulse_time = self.get_clock().now()
            self.get_logger().info(f"[GOAL] 다음 목표: x={self.goal_pose.x:.2f}, y={self.goal_pose.y:.2f}")
        else:
            self.goal_pose = None
            self.state = 'IDLE'
            self.auto_start = False
            self.get_logger().info("[GOAL] 모든 목표 완료. 대기 상태로 전환.")

    # ---------- 상태 업데이트 ----------
    def robot_callback(self, msg):
        self.robot_pose = msg.pose.position
        q = msg.pose.orientation
        siny = 2.0 * (q.w * q.z + q.x * q.y)
        cosy = 1.0 - 2.0 * (q.y**2 + q.z**2)
        self.raw_yaw = math.atan2(siny, cosy)
        self.robot_yaw = self.raw_yaw

        if self.robot_pose is None:
            return
        px, py = self.robot_pose.x, self.robot_pose.y

        # ★ (1) 시작 지점이 바로 게이트 내부인 경우 즉시 상태 보정(1회)
        if not self._first_pose_handled:
            # OFF 게이트 우선
            if any(g.inside_now(px, py) for g in self.disable_gates):
                if self.obstacle_enabled:
                    self.obstacle_enabled = False
                    self.front_blocked = False
                    self.get_logger().warn("[INIT/ZGATE] 시작 위치가 OFF 게이트 내부 → 장애물 인식 OFF")
            elif any(g.inside_now(px, py) for g in self.enable_gates):
                if not self.obstacle_enabled:
                    self.obstacle_enabled = True
                    self.get_logger().info("[INIT/ZGATE] 시작 위치가 ON 게이트 내부 → 장애물 인식 ON")
            self._first_pose_handled = True

        # ★ (2) 래치 트리거
        for gate in self.disable_gates:
            if gate.update_and_fired(px, py):
                if self.obstacle_enabled:
                    self.obstacle_enabled = False
                    self.front_blocked = False
                    self.get_logger().warn("[ZGATE] OFF 게이트 통과 → 장애물 인식 OFF(지속)")
        for gate in self.enable_gates:
            if gate.update_and_fired(px, py):
                if not self.obstacle_enabled:
                    self.obstacle_enabled = True
                    self.get_logger().info("[ZGATE] ON 게이트 통과 → 장애물 인식 ON(지속)")

    # ---------- 라이다 ----------
    def scan_callback(self, scan: LaserScan):
        if not getattr(self, 'obstacle_enabled', True):
            return
        try:
            if not scan.ranges:
                return

            # 기준 유지 + 폭 조절 보정
            half = math.radians(FRONT_FOV_DEG * 0.5)
            effective_offset_deg = LIDAR_YAW_OFFSET_DEG + 0.5 * (FRONT_FOV_BASE_DEG - FRONT_FOV_DEG)
            offset = math.radians(effective_offset_deg)

            ang_min, ang_max, inc = scan.angle_min, scan.angle_max, scan.angle_increment
            from_ang = max(ang_min, -half + offset)  # center - half
            to_ang   = min(ang_max, +half + offset)  # center + half
            if to_ang <= from_ang:
                return

            i_from = max(0, int((from_ang - ang_min) / inc))
            i_to   = min(len(scan.ranges) - 1, int((to_ang   - ang_min) / inc))

            window = []
            rmax = scan.range_max if math.isfinite(scan.range_max) and scan.range_max > 0.0 else float('inf')
            for r in scan.ranges[i_from:i_to+1]:
                if math.isfinite(r) and 0.01 < r < rmax:
                    window.append(r)
            if not window:
                return

            if USE_PCTL:
                window.sort()
                k = max(0, min(len(window)-1, int(len(window)*PCTL/100.0)))
                front_near = window[k]
            else:
                front_near = min(window)

            if not self.front_blocked and front_near < MIN_OBS_DIST_ON:
                self.front_blocked = True
                self.get_logger().info(f"[LIDAR] 전방 차단 감지: ≈{front_near:.2f} m (ON<{MIN_OBS_DIST_ON}m)")
            elif self.front_blocked and front_near > MIN_OBS_DIST_OFF:
                self.front_blocked = False
                self.get_logger().info(f"[LIDAR] 전방 차단 해제: ≈{front_near:.2f} m (OFF>{MIN_OBS_DIST_OFF}m)")

        except Exception as e:
            self.get_logger().warn(f"[LIDAR] 예외: {e}")

    # ---------- 제어 루프 ----------
    def control_loop(self):
        if not self.auto_start:
            return
        if self.robot_pose is None or self.robot_yaw is None or self.goal_pose is None:
            return

        dx = self.goal_pose.x - self.robot_pose.x
        dy = self.goal_pose.y - self.robot_pose.y
        target_yaw = math.atan2(dy, dx) - 0.5 * math.pi
        yaw_err = normalize_angle(target_yaw - self.robot_yaw)
        yaw_err_deg = math.degrees(yaw_err)
        distance = math.hypot(dx, dy)

        cmd = Twist()

        # [SAFETY] 전방 차단 시 회피 시퀀스 진입(중복 진입 방지)
        if getattr(self, 'obstacle_enabled', True) and self.front_blocked and self.state not in (
            'AVOID_TURN_RIGHT', 'AVOID_FORWARD', 'AVOID_TURN_LEFT', 'AVOID_FORWARD_2',
        ):
            self.cmd_pub.publish(Twist())  # 즉시 정지
            # 1) 오른쪽 45°
            self.avoid_target_yaw = normalize_angle(self.robot_yaw - math.pi/4.0)
            self.avoid_start_pos = None
            self.state = 'AVOID_TURN_RIGHT'
            self.last_pulse_time = self.get_clock().now()
            self.get_logger().warn("[SAFETY] 장애물 감지 → 정지 & 회피 시작 (오른쪽 45°)")
            return

        # ➊ 최종 정렬
        if self.state == 'FINAL_ALIGN':
            target_yaw_final = self.final_target_yaw
            yaw_err2 = normalize_angle(target_yaw_final - self.robot_yaw)
            if abs(yaw_err2) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                self.get_logger().info("[STATE] FINAL_ALIGN 완료 → IDLE")
                self.state = 'IDLE'
                self.auto_start = False
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.linear.x = 0.0
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err2) if t < PULSE_ON_SEC else 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.get_logger().info(f"[FINAL_ALIGN] 정렬 중 | yaw_err={math.degrees(yaw_err2):.2f}° → 목표 {math.degrees(target_yaw_final):.2f}°")
            self.cmd_pub.publish(cmd)
            return

        # ➋ 목표 도달
        if distance < GOAL_TOLERANCE:
            self.cmd_pub.publish(Twist())
            if self.goal_queue:
                self.get_logger().info(f"[DONE] 중간 목표 도착 (±{GOAL_TOLERANCE}m). 다음 좌표로 이동.")
                self.set_next_goal()
                return
            else:
                self.get_logger().info("[DONE] 최종 목표 도착. 최종 각도 정렬 시작.")
                self.state = 'FINAL_ALIGN'
                self.last_pulse_time = self.get_clock().now()
                return

        # ➌ 일반 FSM
        if self.state == 'ROTATE':
            if abs(yaw_err) < YAW_THRESHOLD:
                self.get_logger().info(f"[STATE] ROTATE → FORWARD | yaw 오차 {yaw_err_deg:.2f}° < {YAW_THRESHOLD_DEG}°")
                self.state = 'FORWARD'
                cmd.linear.x = LINEAR_SPEED
                self.cmd_pub.publish(cmd)
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.get_logger().info(f"[ROTATE] 회전 중 | yaw_err={yaw_err_deg:.2f}°")
            self.cmd_pub.publish(cmd)

        elif self.state == 'FORWARD':
            cmd.linear.x = LINEAR_SPEED
            if abs(yaw_err) > YAW_THRESHOLD:
                self.get_logger().info(f"[STATE] FORWARD → ROTATE | yaw 오차 {yaw_err_deg:.2f}° > {YAW_THRESHOLD_DEG}°")
                self.state = 'ROTATE'
                self.cmd_pub.publish(cmd)
                return
            cmd.angular.z = 0.0
            self.get_logger().info(f"[FORWARD] 전진 중 | 거리={distance:.2f} m, yaw_err={yaw_err_deg:.2f}°")
            self.cmd_pub.publish(cmd)

        # ➍ 회피 시퀀스 (→R45 →F1 →L45 →F2 →경로 복귀)
        elif self.state == 'AVOID_TURN_RIGHT':
            yaw_err_r = normalize_angle(self.avoid_target_yaw - self.robot_yaw)
            if abs(yaw_err_r) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
                self.state = 'AVOID_FORWARD'
                self.get_logger().info(f"[AVOID] 오른쪽 45° 완료 → 전진 {AVOID_FORWARD_DIST_1:.2f} m")
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err_r) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_FORWARD':
            if self.avoid_start_pos is None:
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
            moved = math.hypot(self.robot_pose.x - self.avoid_start_pos[0],
                               self.robot_pose.y - self.avoid_start_pos[1])
            if moved >= AVOID_FORWARD_DIST_1:
                self.cmd_pub.publish(Twist())
                self.avoid_target_yaw = normalize_angle(self.robot_yaw + math.pi/4.0)  # L45
                self.state = 'AVOID_TURN_LEFT'
                self.last_pulse_time = self.get_clock().now()
                self.get_logger().info("[AVOID] 1차 전진 완료 → 왼쪽 45°")
                return
            cmd.linear.x = LINEAR_SPEED
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_TURN_LEFT':
            yaw_err_l = normalize_angle(self.avoid_target_yaw - self.robot_yaw)
            if abs(yaw_err_l) < YAW_THRESHOLD:
                self.cmd_pub.publish(Twist())
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
                self.state = 'AVOID_FORWARD_2'
                self.get_logger().info(f"[AVOID] 왼쪽 45° 완료 → 전진 {AVOID_FORWARD_DIST_2:.2f} m")
                return
            now = self.get_clock().now()
            t = (now - self.last_pulse_time).nanoseconds / 1e9
            cmd.angular.z = ROTATE_SPEED * math.copysign(1.0, yaw_err_l) if t < PULSE_ON_SEC else 0.0
            cmd.linear.x = 0.0
            if t > PULSE_RESET_SEC:
                self.last_pulse_time = now
            self.cmd_pub.publish(cmd)

        elif self.state == 'AVOID_FORWARD_2':
            if self.avoid_start_pos is None:
                self.avoid_start_pos = (self.robot_pose.x, self.robot_pose.y)
            moved = math.hypot(self.robot_pose.x - self.avoid_start_pos[0],
                               self.robot_pose.y - self.avoid_start_pos[1])
            if moved >= AVOID_FORWARD_DIST_2:
                self.cmd_pub.publish(Twist())
                # ✅ 회피 종료 → 원래 경로 복귀(ROTATE로 정렬 시작)
                self.state = 'ROTATE'
                self.get_logger().info("[AVOID] 2차 전진 완료 → 경로 복귀(ROTATE)")
                return
            cmd.linear.x = LINEAR_SPEED
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)

    # ---------- ✅ STOP 콜백 ----------
    def cb_stop(self, msg: Bool):
        if not msg.data:
            return
        try:
            self.cmd_pub.publish(Twist())
        except Exception:
            pass
        self.auto_start = False
        self.state = 'IDLE'
        self.goal_queue.clear()
        self.goal_pose = None
        self.avoid_target_yaw = None
        self.avoid_start_pos = None
        self.front_blocked = False
        self.get_logger().warn("[STOP] 수신 → 즉시 정지 및 IDLE 전환")

# ===== 통합 main =====
def main():
    # 카메라/Flask 스레드 시작
    cam_thread = threading.Thread(target=camera_loop, name="camera_loop", daemon=True)
    cam_thread.start()

    web_thread = threading.Thread(target=run_flask, name="flask_server", daemon=True)
    web_thread.start()

    # ROS2 시작
    rclpy.init()
    node = ControllerNode()

    # 종료 시그널 처리(선택)
    def _graceful_shutdown(signum, frame):
        raise KeyboardInterrupt()
    try:
        signal.signal(signal.SIGINT, _graceful_shutdown)
        signal.signal(signal.SIGTERM, _graceful_shutdown)
    except Exception:
        pass

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\n[MAIN] KeyboardInterrupt → 종료 준비")
    finally:
        try:
            node.destroy_node()
        except Exception:
            pass
        try:
            rclpy.shutdown()
        except Exception:
            pass

        # 카메라 루프 종료
        global _running
        _running = False
        # daemon 스레드는 프로세스 종료 시 자동 종료되지만, 잠시 기다려줌
        for th in (cam_thread, web_thread):
            try:
                th.join(timeout=1.0)
            except Exception:
                pass
        print("[MAIN] 종료 완료")

if __name__ == '__main__':
    main()
