#!/usr/bin/env python3
import os
import cv2
import numpy as np
import math
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from ament_index_python.packages import get_package_share_directory
from collections import deque
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
def normalize_angle(angle):
    while angle > math.pi:
        angle -= 2.0 * math.pi
    while angle < -math.pi:
        angle += 2.0 * math.pi
    return angle
class MappingNode(Node):
    def __init__(self):
        super().__init__('mapping_node')
        # :흰색_확인_표시: 동시에 추적할 로봇 마커 ID들
        self.target_ids = [25, 26, 27]
        self.marker_len = 0.1
        # 월드 기준 마커 (Affine 계산용)
        self.world_coords = {
            20: (0.0, 0.0),
            21: (0.0, 1.0),
            22: (2.0, 1.0),
            23: (2.0, 0.0),
        }
        # 퍼블리셔
        self.pub_world = self.create_publisher(PoseStamped, '/marker/world_pose', 10)
        # :흰색_확인_표시: ID별 Pose 퍼블리셔 딕셔너리
        self.pub_pinky = {
            mid: self.create_publisher(PoseStamped, f'marker_map/ID{mid}', 10)
            for mid in self.target_ids
        }
        # :흰색_확인_표시: ID별 yaw 스무딩 창
        self.yaw_windows = {mid: deque(maxlen=5) for mid in self.target_ids}
        # 디버그 영상 퍼블리셔
        self.img_pub = self.create_publisher(Image, '/marker/debug_image', 10)
        self.bridge = CvBridge()
        # 보정 로드
        pkg_share = get_package_share_directory('marker_mapping')
        calib = np.load(os.path.join(pkg_share, 'config', 'calibration_result.npz'))
        self.K, self.dist = calib['camera_matrix'], calib['dist_coeffs']
        # ArUco 설정
        self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_250)
        self.aruco_params = cv2.aruco.DetectorParameters_create()
        # 카메라 오픈 (필요시 인덱스 변경)
        self.cap = cv2.VideoCapture(2, cv2.CAP_V4L2)
        if not self.cap.isOpened():
            self.get_logger().error("카메라를 열 수 없습니다")
            raise RuntimeError("카메라 열기 실패")
        self.last_M = None
        self.anchor_locked = False  # :흰색_확인_표시: 한번 계산하면 고정
        self.create_timer(0.05, self.timer_callback)
    def estimate_affine(self, corners, ids):
        image_pts, world_pts = [], []
        for i, mid in enumerate(ids.flatten()):
            if mid in self.world_coords:
                pts = corners[i].reshape(4, 2)
                image_pts.append(pts.mean(axis=0))
                world_pts.append(self.world_coords[mid])
        if len(image_pts) < 4:
            return None
        M, _ = cv2.estimateAffine2D(np.array(image_pts), np.array(world_pts))
        return M
    def publish_marker_pose(self, mid, wx, wy):
        msg = PoseStamped()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'map'
        msg.pose.position.x = wx
        msg.pose.position.y = wy
        msg.pose.orientation.w = 1.0
        self.pub_world.publish(msg)
    def publish_debug_image(self, bgr_img):
        try:
            msg = self.bridge.cv2_to_imgmsg(bgr_img, encoding='bgr8')
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.header.frame_id = 'map'
            self.img_pub.publish(msg)
        except Exception as e:
            self.get_logger().warn(f"디버그 이미지 퍼블리시 실패: {e}")
    def timer_callback(self):
        ret, frame = self.cap.read()
        if not ret:
            return
        img = cv2.undistort(frame, self.K, self.dist)
        corners, ids, _ = cv2.aruco.detectMarkers(img, self.aruco_dict, parameters=self.aruco_params)
        if ids is None:
            # 마커 없어도 GUI로 프레임 계속 송신
            self.publish_debug_image(img)
            cv2.imshow("Mapped", img)
            cv2.waitKey(1)
            return
        ids_list = ids.flatten().tolist()
        present = set(ids_list)
        # 기준 마커 표시 + world 퍼블리시
        base_count = 0
        for i, mid in enumerate(ids_list):
            if mid in self.world_coords:
                base_count += 1
                wx, wy = self.world_coords[mid]
                self.publish_marker_pose(mid, wx, wy)
                text = f"ID{mid}: ({wx:.2f},{wy:.2f})"
                pts = corners[i].reshape(4, 2)
                cx, cy = pts.mean(axis=0).astype(int)
                tw, th = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0]
                tx = cx + 10 if mid in (20, 21) else cx - tw - 10
                cv2.putText(img, text, (tx, cy + th // 2), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        # :흰색_확인_표시: Affine 계산(한 번만) 및 고정 로직
        if not self.anchor_locked:
            if base_count >= 4:
                M = self.estimate_affine(corners, ids)
                if M is not None:
                    self.last_M = M
                    self.anchor_locked = True
                    self.get_logger().info("기준 마커 고정 완료: Affine 행렬을 저장하고 이후 재계산을 중지함")
            else:
                # 아직 고정 못 했으면 대기
                self.get_logger().warn("기준 마커 부족 - 초기 Affine 계산 대기 중")
                self.publish_debug_image(img)
                cv2.imshow("Mapped", img)
                cv2.waitKey(1)
                return
        # 고정 이후에는 base_count와 무관하게 self.last_M 사용
        if self.last_M is None:
            self.publish_debug_image(img)
            cv2.imshow("Mapped", img)
            cv2.waitKey(1)
            return
        # :흰색_확인_표시: 여러 로봇 마커 동시 처리
        for mid in self.target_ids:
            if mid not in present:
                continue
            idx = ids_list.index(mid)
            pts_img = corners[idx].reshape(4, 2).astype(np.float32)
            center_img = pts_img.mean(axis=0)
            # 이미지 → 맵 좌표
            center_map = cv2.transform(center_img[None, None, :], self.last_M)[0, 0, :]
            p0_map = cv2.transform(pts_img[0][None, None, :], self.last_M)[0, 0, :]
            p1_map = cv2.transform(pts_img[1][None, None, :], self.last_M)[0, 0, :]
            vx, vy = (p1_map - p0_map).tolist()
            yaw = math.atan2(vy, vx)
            # ID별 스무딩
            self.yaw_windows[mid].append(yaw)
            filtered_yaw = sum(self.yaw_windows[mid]) / len(self.yaw_windows[mid])
            yaw_deg = math.degrees(normalize_angle(filtered_yaw))
            # 로그 & 오버레이
            self.get_logger().info(f"ID{mid} → x={center_map[0]:.2f}, y={center_map[1]:.2f}, yaw={yaw_deg:.1f}°")
            cx, cy = center_img.astype(int)
            overlay = f"ID{mid}: ({center_map[0]:.2f},{center_map[1]:.2f}), {yaw_deg:.1f}°"
            tw, th = cv2.getTextSize(overlay, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0]
            cv2.circle(img, (cx, cy), 6, (0, 0, 255), 2)
            cv2.putText(img, overlay, (cx - tw - 10, cy - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
            # 퍼블리시 (ID별 토픽)
            ps = PoseStamped()
            ps.header.stamp = self.get_clock().now().to_msg()
            ps.header.frame_id = 'map'
            ps.pose.position.x = float(center_map[0])
            ps.pose.position.y = float(center_map[1])
            ps.pose.orientation.z = math.sin(filtered_yaw / 2.0)
            ps.pose.orientation.w = math.cos(filtered_yaw / 2.0)
            self.pub_pinky[mid].publish(ps)
        # 디버그 영상 퍼블리시 & 화면 미리보기
        self.publish_debug_image(img)
        cv2.imshow("Mapped", img)
        cv2.waitKey(1)
def main():
    # 기본 도메인 ID 자동 설정(환경에 없을 때만). 필요 없으면 이 4줄을 지우면 됨.
    DEFAULT_DOMAIN_ID = "10"
    if not os.environ.get("ROS_DOMAIN_ID"):
        os.environ["ROS_DOMAIN_ID"] = DEFAULT_DOMAIN_ID
        print(f"[mapping_node] ROS_DOMAIN_ID 미설정 → 기본값 {DEFAULT_DOMAIN_ID} 적용")
    rclpy.init()
    node = MappingNode()
    try:
        rclpy.spin(node)
    finally:
        node.cap.release()
        cv2.destroyAllWindows()
        node.destroy_node()
        rclpy.shutdown()
if __name__ == '__main__':
    main()
